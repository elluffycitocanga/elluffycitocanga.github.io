<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Campus UCE - Visualización</title>
  <style>
    /* Estilos generales del body y título */
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #f0f0f0;
    }

    h1 {
      text-align: center;
      background-color: #222;
      color: #fff;
      margin: 0;
      padding: 20px 0;
      font-size: 32px;
    }

    /* Contenedor de botones */
    .button-container {
      text-align: center;
      margin: 10px 0 0 0;
    }

    /* Estilos de los botones */
    button {
      margin: 0 10px;
      padding: 8px 20px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 6px;
      border: 1.5px solid #222;
      background-color: white;
      transition: background-color 0.3s ease;
    }

    /* Cambio de color al pasar el mouse sobre el botón */
    button:hover {
      background-color: #ddd;
    }

    /* Botón activo con fondo oscuro y texto blanco */
    button.active {
      background-color: #222;
      color: white;
    }

    /* Contenedor principal con flexbox: el canvas y el panel info lado a lado */
    .container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      padding: 20px;
    }

    /* Contenedor del canvas con fondo negro y tamaño fijo */
    .canvas-wrapper {
      background-color: #000;
      width: 750px;
      height: 400px;
      position: relative;
      overflow: hidden;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      border: 2px solid black;
      flex-shrink: 0; /* No permitir que se reduzca su tamaño */
    }

    /* Canvas absolutamente posicionado dentro del contenedor para poder desplazar y escalar */
    canvas {
      position: absolute;
      left: 0;
      top: 0;
      user-select: none; /* No permitir selección de texto al arrastrar */
    }

    /* Panel de información a la derecha del canvas */
    .info-panel {
      width: 300px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      border: 2px solid black;
      padding: 15px;
      font-size: 14px;
      color: #222;
      line-height: 1.4;
      user-select: text; /* Permitir selección de texto aquí */
    }

    /* Imagen dentro del panel info, oculta por defecto */
    .info-panel img {
      max-width: 100%;
      margin-bottom: 10px;
      border-radius: 8px;
      display: none;
    }

    /* Título dentro del panel */
    .info-panel h2 {
      margin-top: 0;
      font-size: 18px;
    }

    /* Lista de carreras dentro del panel */
    .info-panel ul {
      padding-left: 20px;
      margin-top: 5px;
    }
  </style>
  </head>
  <body>
    <h1>Campus Universidad Central del Ecuador</h1>

    <!-- Solo botones necesarios -->
    <div class="button-container">
      <button id="btn-original" class="active">Facultades UCE</button>
      <button id="btn-subnodos">Encuentra tu facultad :D</button>
    </div>

    <div class="container">
      <div class="canvas-wrapper" id="canvas-container">
        <canvas id="canvas"></canvas>
      </div>

      <div id="info-panel" class="info-panel">
        <div id="ruta-panel" style="margin-top: 20px; display: none; border-top: 1px solid #ccc; padding-top: 15px;">
          <label for="select-origen"><strong>Origen:</strong></label><br>
          <select id="select-origen" style="width: 100%; margin-bottom: 10px;"></select>

          <label for="select-destino"><strong>Destino:</strong></label><br>
          <select id="select-destino" style="width: 100%; margin-bottom: 10px;"></select>
          <p id="tiempo-ruta" style="font-weight: bold; margin-bottom: 10px; display: none;"></p>
          <button id="btn-calcular-ruta" style="width: 100%; background-color: #222; color: white; border-radius: 6px; padding: 8px 0;">
            Generar ruta
          </button>
        </div>

        <h2 id="panel-title">Selecciona un nodo</h2>
        <img id="panel-image" src="" alt="Imagen Facultad" />
        <p id="panel-info"></p>
        <div id="panel-carreras"></div>
      </div>
    </div>

    <script>
      // Variables DOM
      let ultimaRuta = [];
      const rutaPanel = document.getElementById('ruta-panel');
      const selectOrigen = document.getElementById('select-origen');
      const selectDestino = document.getElementById('select-destino');
      const btnCalcularRuta = document.getElementById('btn-calcular-ruta');

      const canvas = document.getElementById('canvas');
      const container = document.getElementById('canvas-container');
      const ctx = canvas.getContext('2d');

      const panelTitle = document.getElementById('panel-title');
      const panelInfo = document.getElementById('panel-info');
      const panelCarreras = document.getElementById('panel-carreras');
      const panelImage = document.getElementById('panel-image');

      const btnOriginal = document.getElementById('btn-original');
      const btnSubnodos = document.getElementById('btn-subnodos');

      // Variables para nodos y aristas
      let nodesOriginal = [];
      let edgesOriginal = [];
      let nodesSubnodos = [];
      let edgesSubnodos = [];

      let currentNodes = [];
      let currentEdges = [];

      let image = new Image();
      image.src = 'fondo.jpg';

      // Variables zoom y pan
      let scale = 1, minScale = 1, maxScale = 2;
      let offsetX = 0, offsetY = 0;
      let isDragging = false, startDrag = { x: 0, y: 0 };
      let selectedNode = null;

    let draggingSubnode = null;  // Nodo subnodo que se está arrastrando
    let dragOffset = { x: 0, y: 0 }; // Offset entre click y el centro del nodo

    // Posiciones fijas predefinidas para nodos originales, por id
    const posiciones = {
      1: { x: 863, y: 157 },
      2: { x: 444, y: 258 },
      3: { x: 660, y: 238 },
      4: { x: 516, y: 56 },
      5: { x: 649, y: 68 },
      6: { x: 584, y: 84 },
      7: { x: 702, y: 85 },
      8: { x: 816, y: 359 },
      9: { x: 830, y: 169 },
      10: { x: 521, y: 279 },
      11: { x: 579, y: 191 },
      12: { x: 525, y: 90 },
      13: { x: 840, y: 118 },
      14: { x: 252, y: 220 },
      15: { x: 829, y: 206 },
      16: { x: 452, y: 351 },
      17: { x: 23, y: 70 },
      18: { x: 858, y: 366 },
      19: { x: 950, y: 140 },
      20: { x: 829, y: 48 },
      21: { x: 538, y: 23},
      22: { x: 927, y: 204}
    };

    const posicionesSubnodosFijas = {
      1001: { x: 600, y: 160 },
      1002: { x: 620, y: 170 },
      1003: { x: 640, y: 180 },
      1004: { x: 660, y: 190 },
      1005: { x: 680, y: 200 },
      // Agrega aquí todos los subnodos que hayas generado con IDs fijos y sus coordenadas deseadas
      // IMPORTANTE: asegúrate de que los IDs coincidan con los generados por tu función de subnodos
    };

    // Ajustar tamaño del canvas al tamaño del contenedor y dibujar
    function resizeCanvas() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      draw();
    }
    // Escuchar evento de redimensionar ventana
    window.addEventListener('resize', resizeCanvas);

    // Eventos para arrastrar el canvas (pan)
    container.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / scale;
    const y = (e.clientY - rect.top - offsetY) / scale;

    /*draggingSubnode = null;
    for (let node of currentNodes) {
      if (node.isSubnodo) {
        const dx = node.x - x;
        const dy = node.y - y;
        if (Math.sqrt(dx * dx + dy * dy) < 10) {
          draggingSubnode = node;
          dragOffset.x = x - node.x;
          dragOffset.y = y - node.y;
          break;
        }
      }
    }*/

    if (!draggingSubnode) {
      isDragging = true;
      startDrag.x = e.clientX - offsetX;
      startDrag.y = e.clientY - offsetY;
    }
  });
    container.addEventListener('mouseup', () => {
    if (draggingSubnode) {
      //guardarPosicionesSubnodos();
    }
    draggingSubnode = null;
    isDragging = false;
  });

    container.addEventListener('mouseleave', () => {
    if (draggingSubnode) {
      //guardarPosicionesSubnodos();
    }
    draggingSubnode = null;
    isDragging = false;
  });

    container.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / scale;
    const y = (e.clientY - rect.top - offsetY) / scale;

    if (draggingSubnode) {
      // Actualizar la posición del subnodo
      draggingSubnode.x = x - dragOffset.x;
      draggingSubnode.y = y - dragOffset.y;
      draw();
    }
     else if (isDragging) {
      offsetX = e.clientX - startDrag.x;
      offsetY = e.clientY - startDrag.y;
      clampOffset();
      draw();
    }
  });

    function guardarPosicionesSubnodos() {
    const posicionesGuardadas = {};
    nodesSubnodos.forEach(node => {
      if (node.isSubnodo) {
        posicionesGuardadas[node.id] = { x: node.x, y: node.y };
      }
    });
    localStorage.setItem('posicionesSubnodos', JSON.stringify(posicionesGuardadas));
  }

    // Evento para zoom con rueda del mouse
    container.addEventListener('wheel', e => {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();

      // Coordenadas del mouse en relación a la imagen sin zoom y offset
      const mouseX = (e.clientX - rect.left - offsetX) / scale;
      const mouseY = (e.clientY - rect.top - offsetY) / scale;

      const zoomFactor = 0.1;
      if (e.deltaY < 0) {
        scale *= 1 + zoomFactor; // Zoom in
      } else {
        scale *= 1 - zoomFactor; // Zoom out
      }

      // Limitar escala
      scale = Math.min(maxScale, Math.max(minScale, scale));

      // Ajustar offset para que el zoom sea centrado en el cursor
      offsetX = e.clientX - rect.left - mouseX * scale;
      offsetY = e.clientY - rect.top - mouseY * scale;

      clampOffset();
      draw();
    });

    // Limita el desplazamiento para que la imagen no quede fuera del canvas
    function clampOffset() {
      const maxOffsetX = 0;
      const maxOffsetY = 0;
      const minOffsetX = canvas.width - image.width * scale;
      const minOffsetY = canvas.height - image.height * scale;

      offsetX = Math.min(maxOffsetX, Math.max(minOffsetX, offsetX));
      offsetY = Math.min(maxOffsetY, Math.max(minOffsetY, offsetY));
    }

    // Función para dibujar toda la escena: imagen, aristas y nodos
    function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();

    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    ctx.drawImage(image, 0, 0);

    // Dibuja aristas pequeñas (subaristas)
    ctx.strokeStyle = '#0066cc';
    ctx.lineWidth = 2;
    currentEdges.forEach(edge => {
      const from = currentNodes.find(n => n.id === edge.from);
      const to = currentNodes.find(n => n.id === edge.to);
      if (from && to) {
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }
    });

    // En modo subnodos, dibuja etiquetas totales con aristas originales
    if (btnSubnodos.classList.contains('active')) {
      edgesOriginal.forEach(edge => {
        const from = currentNodes.find(n => n.id === edge.from && !n.isSubnodo);
        const to = currentNodes.find(n => n.id === edge.to && !n.isSubnodo);
        if (from && to && edge.time) {
          const midX = (from.x + to.x) / 2;
          const midY = (from.y + to.y) / 2;
          ctx.fillStyle = 'black';
          ctx.font = '14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          //ctx.fillText(edge.time, midX, midY);
        }
      });
    } else {
      // Modo original dibuja etiquetas normales
      currentEdges.forEach(edge => {
        const from = currentNodes.find(n => n.id === edge.from);
        const to = currentNodes.find(n => n.id === edge.to);
        if (from && to && edge.time) {
          const midX = (from.x + to.x) / 2;
          const midY = (from.y + to.y) / 2;
          ctx.fillStyle = 'black';
          ctx.font = '14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(edge.time, midX, midY);
        }
      });
    }

    // Dibuja nodos igual que antes
    currentNodes.forEach(node => {
      ctx.beginPath();
      if(node.isSubnodo) {
        ctx.fillStyle = 'red';
        ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);
      } else {
        ctx.fillStyle = (node === selectedNode) ? 'blue' : 'black';
        ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
      }
      ctx.fill();

      if(!node.isSubnodo) {
        ctx.fillStyle = 'yellow';
        ctx.font = '12px Arial';
        ctx.fillText(node.id, node.x, node.y + 4);
      }
    });
    // Dibuja nodos
      currentNodes.forEach(node => {
        ctx.beginPath();
        if(node.isSubnodo) {
          ctx.fillStyle = 'red';
          ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);
        } else {
          ctx.fillStyle = (node === selectedNode) ? 'blue' : 'black';
          ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
        }
        ctx.fill();

        if(!node.isSubnodo) {
          ctx.fillStyle = 'yellow';
          ctx.font = '12px Arial';
          ctx.fillText(node.id, node.x, node.y + 4);
        }
      });

      // Dibuja ruta generada en verde si existe
      if (ultimaRuta.length > 1) {
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 4;
        ctx.beginPath();
        for (let i = 0; i < ultimaRuta.length - 1; i++) {
          const from = currentNodes.find(n => n.id == ultimaRuta[i]);
          const to = currentNodes.find(n => n.id == ultimaRuta[i + 1]);
          if (from && to) {
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
          }
        }
        ctx.stroke();
      }

      ctx.restore();
    }
    // Detectar click en nodos para mostrar info en panel lateral
    container.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offsetX) / scale;
    const y = (e.clientY - rect.top - offsetY) / scale;

    selectedNode = null;
    const modoSubnodosActivo = btnSubnodos.classList.contains('active');

    for (let node of currentNodes) {
      const dx = node.x - x;
      const dy = node.y - y;
      if (Math.sqrt(dx * dx + dy * dy) < 10) {
        selectedNode = node;

        if (modoSubnodosActivo && node.isSubnodo) {
          // En modo subnodos y clic en subnodo: no mostrar info, solo limpiar panel
          panelTitle.textContent = 'Selecciona un nodo';
          panelInfo.textContent = '';
          panelCarreras.innerHTML = '';
          panelImage.style.display = 'none';
        } else {
          // Mostrar info normal para nodos principales o en modo original
          panelTitle.textContent = node.label;
          panelInfo.textContent = node.info;

          if (node.carreras && node.carreras.length > 0) {
            const listaCarreras = node.carreras.map(c => `- ${c}`).join('<br>');
            panelCarreras.innerHTML = `<strong>Carreras:</strong><br>${listaCarreras}`;
          } else {
            panelCarreras.innerHTML = '📌 Puedes guiarte con esta foto 😀';
          }

          if (node.img) {
            panelImage.src = node.img;
            panelImage.style.display = 'block';
          } else {
            panelImage.style.display = 'none';
          }
        }

        break;
      }
    }

    if (!selectedNode) {
      panelTitle.textContent = 'Selecciona un nodo';
      panelInfo.textContent = '';
      panelCarreras.innerHTML = '';
      panelImage.style.display = 'none';
    }
    draw();
    });
    /**
     * Función que genera subnodos intermedios en aristas que tienen tiempo > 1
     * para dividir la arista en segmentos de 1 minuto (o unidad de tiempo).
     * Crea nodos intermedios y nuevas aristas entre ellos.
     * 
     * @param {Object} data - Datos con nodos y aristas originales
     * @param {Object} posiciones - Posiciones fijas para nodos originales
     * @returns {Object} Nuevo grafo con nodos y aristas con subnodos incluidos
     */
    function generarSubnodosYNuevasAristas(data, posiciones) {
    let nextId = Math.max(...data.nodes.map(n => n.id)) + 1; // ID para subnodos

    const nuevosNodos = [];
    const nuevasAristas = [];

     const aristasProcesadas = new Set();

    const nodosOriginales = data.nodes.map(n => ({
      ...n,
      x: posiciones[n.id]?.x ?? 100,
      y: posiciones[n.id]?.y ?? 100,
      isSubnodo: false
    }));

    data.edges.forEach(edge => {
      const aristaId = `${edge.from}-${edge.to}`;
      if (aristasProcesadas.has(aristaId)) {
        return;
      }
    aristasProcesadas.add(aristaId);
      const fromNode = nodosOriginales.find(n => n.id === edge.from);
      const toNode = nodosOriginales.find(n => n.id === edge.to);

      if (!fromNode || !toNode) {
        console.warn(`Arista con nodos no encontrados: from=${edge.from} to=${edge.to}`);
        return;
      }

      let tiempo = parseInt(edge.time, 10);
        if (isNaN(tiempo) || tiempo <= 1) {
          tiempo = 1;
        }

      if (tiempo <= 1) {
        nuevasAristas.push({
          from: fromNode.id,
          to: toNode.id,
          label: edge.label,
          weight: edge.weight,
          time: edge.time
        });
        return;
      }

      // Crear subnodos intermedios
       const subnodos = [];
      for (let i = 1; i < tiempo; i++) {
        const ratio = i / tiempo;
        const x = fromNode.x + (toNode.x - fromNode.x) * ratio;
        const y = fromNode.y + (toNode.y - fromNode.y) * ratio;
        const subnodo = {
          id: nextId++,
          label: `Subnodo ${fromNode.id}-${toNode.id} #${i}`,
          info: ``,
          carreras: [],
          img: null,
          x,
          y,
          isSubnodo: true
        };
        subnodos.push(subnodo);
      }

      nuevosNodos.push(...subnodos);

      nuevasAristas.push({
        from: fromNode.id,
        to: subnodos[0].id,
        label: '',
        weight: edge.weight / tiempo,
        time: ''
      });

      for (let i = 0; i < subnodos.length - 1; i++) {
        nuevasAristas.push({
          from: subnodos[i].id,
          to: subnodos[i + 1].id,
          label: '',
          weight: edge.weight / tiempo,
          time: ''
        });
      }

      nuevasAristas.push({
        from: subnodos[subnodos.length - 1].id,
        to: toNode.id,
        label: '',
        weight: edge.weight / tiempo,
        time: ''
      });
    });

    return {
      nodes: [...nodosOriginales, ...nuevosNodos],
      edges: nuevasAristas
    };
  }

    // Función que carga el archivo JSON con nodos y aristas
    async function loadData() {
      try {
        const res = await fetch('campus.json');
        const data = await res.json();

        // Preparar nodos originales con posiciones fijas
        nodesOriginal = data.nodes.map(n => ({
          ...n,
          x: posiciones[n.id]?.x ?? 100,
          y: posiciones[n.id]?.y ?? 100,
          isSubnodo: false
        }));
        edgesOriginal = data.edges;

        // Generar grafo con subnodos intermedios
        const grafoSubnodos = generarSubnodosYNuevasAristas(data, posiciones);
        console.log("Subnodos generados:");
        grafoSubnodos.nodes
          .filter(n => n.isSubnodo)
          .forEach(n => {
            console.log(`ID: ${n.id}, x: ${Math.round(n.x)}, y: ${Math.round(n.y)}`);
          });
        nodesSubnodos = grafoSubnodos.nodes;
        edgesSubnodos = grafoSubnodos.edges;

        // Recuperar posiciones guardadas si existen
        const posicionesGuardadasJSON = localStorage.getItem('posicionesSubnodos');
        const posicionesGuardadas = posicionesGuardadasJSON ? JSON.parse(posicionesGuardadasJSON) : {};

        grafoSubnodos.nodes.forEach(node => {
          if (node.isSubnodo) {
            if (posicionesGuardadas[node.id]) {
              node.x = posicionesGuardadas[node.id].x;
              node.y = posicionesGuardadas[node.id].y;
            } else if (posicionesSubnodosFijas[node.id]) {
              node.x = posicionesSubnodosFijas[node.id].x;
              node.y = posicionesSubnodosFijas[node.id].y;
            }
          }
        });

        // Inicializar con grafo original
        currentNodes = nodesOriginal;
        currentEdges = edgesOriginal;

        // Ajustar escala mínima y máxima según tamaño del contenedor y la imagen
        const scaleX = container.clientWidth / image.width;
        const scaleY = container.clientHeight / image.height;
        minScale = Math.max(scaleX, scaleY);
        scale = minScale * 1.5;
        maxScale = minScale * 2;

        // Centrar la imagen en el contenedor
        offsetX = (container.clientWidth - image.width * scale) / 2;
        offsetY = (container.clientHeight - image.height * scale) / 2;

        clampOffset();
        resizeCanvas();

      } catch (e) {
        alert("❌ Error al cargar el archivo JSON: " + e.message);
      }
    }
    /**
     * Cambia entre el modo de visualización 'original' y 'subnodos'
     * Actualiza los nodos y aristas a dibujar, así como los estilos de botones
     */
    function cambiarGrafo(tipo) {
      if (tipo === 'original') {
        currentNodes = nodesOriginal;
        currentEdges = edgesOriginal;
        btnOriginal.classList.add('active');
        btnSubnodos.classList.remove('active');
        rutaPanel.style.display = 'none'; // Solo mostrar panel ruta en modo subnodos
      } else if (tipo === 'subnodos') {
        currentNodes = nodesSubnodos;
        currentEdges = edgesSubnodos;
        btnOriginal.classList.remove('active');
        btnSubnodos.classList.add('active');
        rutaPanel.style.display = 'block';

        // Llenar selects con nodos principales
        selectOrigen.innerHTML = '';
        selectDestino.innerHTML = '';
        const nodosPrincipales = nodesSubnodos.filter(n => !n.isSubnodo);
        nodosPrincipales.forEach(node => {
          const option1 = document.createElement('option');
          option1.value = node.id;
          option1.textContent = node.label;
          selectOrigen.appendChild(option1);

          const option2 = document.createElement('option');
          option2.value = node.id;
          option2.textContent = node.label;
          selectDestino.appendChild(option2);
        });
      }

      selectedNode = null;
      panelTitle.textContent = 'Selecciona un nodo';
      panelInfo.textContent = '';
      panelCarreras.innerHTML = '';
      panelImage.style.display = 'none';

      clampOffset();
      draw();
    }


    // Asociar eventos a botones para cambiar modo
    btnOriginal.addEventListener('click', () => cambiarGrafo('original'));
    btnSubnodos.addEventListener('click', () => cambiarGrafo('subnodos'));
    btnCalcularRuta.addEventListener('click', () => {
    const origen = selectOrigen.value;
    const destino = selectDestino.value;

    if (!origen || !destino || origen === destino) {
      alert("⚠️ Por favor, selecciona nodos distintos de origen y destino.");
      return;
    }

    const path = dijkstra(currentNodes, currentEdges, origen, destino);

    if (path.length === 0) {
      alert("❌ No se encontró un camino.");
      return;
    }

    // Calcular tiempo total sumando pesos de aristas entre nodos del path
    let tiempoTotal = 0;
    for (let i = 0; i < path.length - 1; i++) {
      const from = path[i];
      const to = path[i + 1];

      // Buscar la arista que conecta estos dos nodos (en cualquiera de los sentidos)
      const edge = currentEdges.find(e =>
        (String(e.from) === String(from) && String(e.to) === String(to)) ||
        (String(e.to) === String(from) && String(e.from) === String(to))
      );

      if (edge) {
        const peso = parseFloat(edge.weight);
        const pesoValido = (!isNaN(peso) && peso > 0) ? peso : 1;
        tiempoTotal += pesoValido;
      } else {
        // Si no encuentra la arista, sumar 0 o manejar error si quieres
      }
    }

    // Mostrar tiempo total en el panel
    const tiempoRutaElem = document.getElementById('tiempo-ruta');
    tiempoRutaElem.textContent = `⏱ Tiempo estimado: ${tiempoTotal.toFixed(2)} minutos`;
    tiempoRutaElem.style.display = 'block';

    // Dibujar ruta
    draw();

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 4;
    ctx.beginPath();

    for (let i = 0; i < path.length - 1; i++) {
      const from = currentNodes.find(n => n.id == path[i]);
      const to = currentNodes.find(n => n.id == path[i + 1]);
      if (from && to) {
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
      }
    }

    ctx.stroke();
    ctx.restore();
    ultimaRuta = path; // Guardar la ruta para que se dibuje después

    draw();

    alert("✅ Ruta generada con éxito.");
  });
    // Cuando la imagen de fondo se carga, iniciar carga de datos y dibujo
    image.onload = () => {
      loadData();
    };

    // Algoritmo de Dijkstra
    function dijkstra(nodes, edges, startId, endId) {
    // Convertir IDs a string para uniformidad
    startId = String(startId);
    endId = String(endId);

    const dist = {};
    const prev = {};
    const visited = new Set();

    // Inicializar distancias
    for (let node of nodes) {
      dist[String(node.id)] = Infinity;
      prev[String(node.id)] = null;
    }

    dist[startId] = 0;

    while (visited.size < nodes.length) {
      // Encontrar nodo no visitado con distancia mínima
      let u = null;
      let minDist = Infinity;

      for (let id in dist) {
        if (!visited.has(id) && dist[id] < minDist) {
          minDist = dist[id];
          u = id;
        }
      }

      if (u === null) break; // No quedan nodos accesibles

      // Si ya llegamos al destino, rompemos el ciclo
      if (u === endId) break;

      visited.add(u);

      // Revisar vecinos (aristas que parten o llegan a u para grafo no dirigido)
      for (let edge of edges) {
        // Normalizar IDs de arista
        const from = String(edge.from);
        const to = String(edge.to);

        let neighbor = null;
        if (from === u) {
          neighbor = to;
        } else if (to === u) {
          neighbor = from; // Grafo no dirigido: considerar aristas inversas también
        }

        if (neighbor && !visited.has(neighbor)) {
          const peso = parseFloat(edge.weight);
          const pesoValido = (!isNaN(peso) && peso > 0) ? peso : 1;

          const alt = dist[u] + pesoValido;

          if (alt < dist[neighbor]) {
            dist[neighbor] = alt;
            prev[neighbor] = u;
          }
        }
      }
    }

    // Reconstruir camino
    const path = [];
    let u = endId;
    while (u !== null) {
      path.unshift(u);
      u = prev[u];
    }

    if (path[0] !== startId) return []; // No hay camino

    return path;
  }
  
  </script>
  
</body>
</html>
